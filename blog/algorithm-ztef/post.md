## 一个问题

> 离线求区间第$k$小，区间长为$n$，操作数为$m$，数字最大为$c$。

<span class="cf-black-red">Siyuan</span>大佬:“主席树$O\left( (n+m)\log c\right)$秒杀！”

> 禁用线段树！

<span class="cf-black-red">stepsys</span>大佬:“使用整体二分！”

那么，整体二分是什么？

## 普通二分

我们先考虑用普通的二分答案算法解决本题，对于每个数都二分答案一次，复杂度$O(nm\log c)$。很显然，这样的做法会**TLE**。

那么我们都干了些什么呢？

在每次二分的每一轮，都需要：

1.处理所有区间内的数，统计$\le mid$的数的个数；

2.根据结果取左边或右边。

注意到第$1$步在$mid$相同的前提下是可以用树状数组预处理的。这意味着如果能把所有$mid$相同的轮统一处理，就有希望降低复杂度。

## 整体二分

把所有$mid$相同的轮统一处理的需求意味着我们必须**统一处理所有询问**。这也意味着整体二分是一个**离线算法**。我们不妨设`solve(q,l,r)`表示对询问序列$q$，答案区间$[l,r]$进行整体二分的过程，那么这个过程应该看起来像这样：

1.处理所有数，用树状数组维护区间$\le mid$的数的个数；

2.对于$q$中的每个询问，求出它应该去左区间还是右区间，分为$q1$和$q2$两类。

3.`solve(q1,l,mid);solve(q2,mid+1,r);`

看上去效率提高了！

冷静分析，不同的$mid$可以有$O(m\log c)$种，每种$mid$需要$O(n)$时间……**TLE**

怎么办？$mid$种数似乎无法再优化，但每种$mid$是否非得$O(n)$不可呢？

考虑在`slove(q,l,r)`时，数被根据是否$\le mid$自动分为两类。对于$\le mid$的那些，这些数对$q1$的影响还需考虑，但它们一定不比在$q2$的所有二分的$mid$大；对于剩下的那些，这些数对$q2$的影响还需考虑,但它们一定对在$q2$的所有二分没有影响。因此，我们可以在把询问分成两类时把数也分成两类，分别递归。值得一提的是，如果把数字本身看成**加数操作**，那么就可以统一处理数字与询问，并且在后续问题中可以产生巨大的好处。

复杂度？$O(\text{先咕着，反正能过})$